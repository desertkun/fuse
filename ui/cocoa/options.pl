#!/usr/bin/perl -w

# options.pl: generate options dialog boxes
# $Id$

# Copyright (c) 2002-2004 Philip Kendall

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Author contact information:

# E-mail: philip-fuse@shadowmagic.org.uk

use strict;

use Fuse;
use Fuse::Dialog;

die "No data file specified" unless @ARGV;

my @dialogs = Fuse::Dialog::read( shift @ARGV );

my %combo_sets;
my %combo_default;

print Fuse::GPL( 'options.c: options dialog boxes',
		 '2001-2004 Philip Kendall' ) . << "CODE";

/* This file is autogenerated from options.dat by options.pl.
   Do not edit unless you know what you\'re doing! */

#include <config.h>

#import <Foundation/NSArray.h>
#import <Foundation/NSString.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#import "options_cocoa.h"

#include "compat.h"
#include "fuse.h"
#include "options.h"
#include "settings.h"

static int
option_enumerate_combo( char **options, char *value, guint count, int def ) {
  int i;
  if( value != NULL ) {
    for( i = 0; i < count; i++) {
      if( !strcmp( value, options[ i ] ) )
        return i;
    }
  }
  return def;
}

static const char*
option_enumerate_combo_string( char **options, const char *value, guint count,
                               int def ) {
  int i;
  if( value != NULL ) {
    for( i = 0; i < count; i++) {
      if( !strcmp( value, options[ i ] ) )
        return options[ i ];
    }
  }
  return options[ def ];
}

CODE

foreach( @dialogs ) {

    foreach my $widget ( @{ $_->{widgets} } ) {

	foreach my $type ( $widget->{type} ) {

	    my $text = $widget->{text}; $text =~ tr/()//d;

	    if( $type eq "Combo" ) {
		my $n = 0;

		foreach( split( /\|/, $widget->{data1} ) ) {
		    if( /^\*/ ) {
			$combo_default{$widget->{value}} = $n;
		    }
		    $n++;
		}
		$n = 0;
		$widget->{data1} =~ s/^\*//;
		$widget->{data1} =~ s/\|\*/|/;
		if( not exists( $combo_sets{$widget->{data1}} ) ) {
                    my $zzz = "$_->{name}_$widget->{value}_combo";
		    $combo_sets{$widget->{data1}} = "$_->{name}_$widget->{value}";

		    print << "CODE";

static char * $_->{name}_$widget->{value}_combo[] = {
CODE
		    foreach( split( /\|/, $widget->{data1} ) ) {
			print << "CODE";
  "$_",
CODE
			$n++;
		    }
		    print << "CODE";
};

static const guint $_->{name}_$widget->{value}_combo_count = $n;

CODE

		    print << "CODE";
NSArray *
cocoa_$_->{name}_$widget->{value}( void )
{
  static NSArray* array = nil;
  
  if( array == nil ) {
    array = [NSArray arrayWithObjects:
CODE
                    $n = 0;
		    foreach( split( /\|/, $widget->{data1} ) ) {
			print << "CODE";
              @(${zzz}[$n]),
CODE
			$n++;
		    }
		    print << "CODE";
              nil ];
  }

  return array;
}

CODE
		} else {
		    print << "CODE";
\#define $_->{name}_$widget->{value}_combo $combo_sets{$widget->{data1}}_combo
\#define $_->{name}_$widget->{value}_combo_count $combo_sets{$widget->{data1}}_combo_count

NSArray *
cocoa_$_->{name}_$widget->{value}( void )
{
  return cocoa_$combo_sets{$widget->{data1}}();
}

CODE
		}
		print << "CODE";
int
option_enumerate_$_->{name}_$widget->{value}( void ) {
  return option_enumerate_combo( $_->{name}_$widget->{value}_combo,
				 settings_current.$widget->{value},
				 $_->{name}_$widget->{value}_combo_count,
				 $combo_default{$widget->{value}} );
}

const char*
option_enumerate_string_$_->{name}_$widget->{value}( const char* value ) {
  return option_enumerate_combo_string( $_->{name}_$widget->{value}_combo,
                                        value,
                                        $_->{name}_$widget->{value}_combo_count,
                                        $combo_default{$widget->{value}} );
}

CODE
	    }
	}
    }

}

print << "CODE"

CODE
